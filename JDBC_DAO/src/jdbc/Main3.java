package jdbc;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.Month;
import java.util.stream.Stream;

public class Main3 {
    public static void main(String[] args) {
        DAOAdapterInterface userDAO = new DAOAdapter(new DAO1("scheme1"));
//        TargetUserDAOInterface userDAO = new DAOAdapter(new DAO2("scheme1"));
        
        Stream.of(userDAO.searchAllClients()).forEach(System.out::println);
        System.out.println("");        
        
        Stream.of(userDAO.searchClientByName("client1")).forEach(System.out::println);
        Stream.of(userDAO.searchClientByName("client2")).forEach(System.out::println);
        Stream.of(userDAO.searchClientByName("client3")).forEach(System.out::println);
        System.out.println("");
        
        System.out.println(userDAO.searchClientById(1));
        System.out.println(userDAO.searchClientById(2));
        System.out.println(userDAO.searchClientById(3));
        System.out.println("");
        
        /*the id is dynamically generated by the dbms, not by the insert sql command. For knowing the id, some other parameter must be searched
        after the insertion is done. A unique parameter would be preferred for avoiding duplicity.*/
        Client c1 = new Client("client10", new BigDecimal("20000.50"),LocalDate.of(1950, Month.NOVEMBER, 10),LocalDateTime.of(1999, Month.MAY, 10, 12, 0),3);
        userDAO.insertClient(c1);
        Stream.of(userDAO.searchAllClients()).forEach(System.out::println);
        System.out.println("");
        
        /*the deletion is by name. Therefore, all rows with that same name are deleted.*/
        userDAO.deleteClient(c1);
        Stream.of(userDAO.searchAllClients()).forEach(System.out::println);
        System.out.println("");
        
        /*the update is by id. As the id value initially is unknown, for updating a client, the client must first be inserted (if he has not been yet) and 
        searched for at the DB, so that one or more values with that name is returned, with a valid id, and the rows with that id be updated with the new 
        values. Instead of searchClientByName(), which might return multiple values (unless name is set unique at the DB scheme), it would be better to use 
        searchClientById, which would return the one and only possible row - but, for that, the client would have to know his id previously. For facilitating 
        this example, the name was chosen as the client search parameter, and all rows returned are updated with the same new values.*/
        Client oldClient = new Client("client10", new BigDecimal("20000.50"),LocalDate.of(1950, Month.NOVEMBER, 10),LocalDateTime.of(1999, Month.MAY, 10, 12, 0),3);
        userDAO.insertClient(oldClient);
        Client[] clientArray = userDAO.searchClientByName(oldClient.getName());
        Client newClient = new Client("client15", new BigDecimal("200.40"),LocalDate.of(1950, Month.NOVEMBER, 10),LocalDateTime.of(1999, Month.MAY, 10, 12, 0),1);
        Stream.of(clientArray).forEach(x->userDAO.updateClient(x, newClient));
        Stream.of(userDAO.searchAllClients()).forEach(System.out::println);
        userDAO.deleteClient(newClient);
        System.out.println("");
    }
}
